- global functions vs member functions: this is purely an esthetic decision and does not change anything about anything. Should not be subject to a big debate.
	- UPDATE(02/11/2022): in fact it is not. Member functions couple the api to the memory layout, which seems invalid and counter productive in terms of compile times. I am working on math functions on basic math types at the moment. The api changes a lot, but the memory never does. I think this is the case most of the time, which would be in favor of a memory/api declaration separation.
- I should try to go away from global scopes, especially global ctors/dtors as much as possible. Not having control over init/deinit order is a big issue.
- maybe compilation can be sped up with pch
https://stackoverflow.com/questions/28868049/decrease-clang-compile-time-with-precompiled-headers

À propos du hot-reload complètement indépendant des modules:
Si on veut pouvoir utiliser explicitement des symboles d'une librairie dans une autre, il faut la lui linker au moment du link. Dés qu'on fait ça, windows va vouloir la charger à la volée dés qu'on va charger notre lib. Sous windows, il existe un moyen de passer en mode "lazy load" (ça s'appelle le DelayLoad, voir plus bas), qui ne déclenche le chargement de la lib dés qu'un symbole de la dite lib est résolu au runtime, mais une fois qu'une lib est chargée comme ça, impossible de la déloader indépendemment dans que le symbole est utilisé. À moins de trouver une solution à ça, ce sera impossible de rendre yae hot-relodable.
Plus d'infos sur les Delay Loaded Libraries:
Delay loaded library allows us to choose when the libray is loaded but
prevents us from unloading the lib whenever we want.
If we declare the WindowApplication in main, it will be impossible to unload the yae.dll.
It works though if WindowApplication is declared in the yae module.
Maybe I am missing something with the __FUnloadDelayLoadedDLL2 function (it always returns false)
I suspect that it never finds the dll, but I need to be sure
https://learn.microsoft.com/en-us/cpp/build/reference/linker-support-for-delay-loaded-dlls?view=msvc-170
https://learn.microsoft.com/en-us/cpp/build/reference/understanding-the-helper-function?view=msvc-170
https://learn.microsoft.com/en-us/cpp/build/reference/delayload-delay-load-import?view=msvc-170
https://learn.microsoft.com/en-us/cpp/build/reference/delay-delay-load-import-settings?view=msvc-170

16/08/2022 - problèmes observés:
- il y a définitivement un gros problème avec l'ordre d'init des types de mirror. J'ai croisé un cas ou un type s'enregistre avant les types primitif, ce qui fait qu'il est incapable de register ses membres correctement. Il faut réfléchir à une manière d'executer ça complètement hors de la phase d'init statique.
- Les serializers mirror font n'imp lorsque il manque des membres dans ce qu'ils essaient de serialiser. Il faudrait probablement être un peu moins rigide et passer à la suite quand un membre est manquant. C'est plutot à l'implem de décider, mais les fonctions de serialization mirror sont des implems

